'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var React = _interopDefault(require('react'));

var changedArray = function (a, b) {
  if (a === void 0) {
    a = [];
  }

  if (b === void 0) {
    b = [];
  }

  return a.length !== b.length || a.some(function (item, index) {
    return !Object.is(item, b[index]);
  });
};

var initialState = {
  error: null,
  info: null
};

var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(ErrorBoundary, _React$Component);

  function ErrorBoundary() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.state = initialState;

    _this.resetErrorBoundary = function () {
      var _this$props;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);

      _this.setState(initialState);
    };

    return _this;
  }

  var _proto = ErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;

    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info == null ? void 0 : info.componentStack);
    this.setState({
      error: error,
      info: info
    });
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var error = this.state.error;
    var resetKeys = this.props.resetKeys;

    if (error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
      var _this$props$onResetKe, _this$props3;

      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
      this.setState(initialState);
    }
  };

  _proto.render = function render() {
    var _this$state = this.state,
        error = _this$state.error,
        info = _this$state.info;
    var _this$props4 = this.props,
        fallbackRender = _this$props4.fallbackRender,
        FallbackComponent = _this$props4.FallbackComponent,
        fallback = _this$props4.fallback;

    if (error !== null) {
      var props = {
        componentStack: info == null ? void 0 : info.componentStack,
        error: error,
        resetErrorBoundary: this.resetErrorBoundary
      };

      if ( /*#__PURE__*/React.isValidElement(fallback)) {
        return fallback;
      } else if (typeof fallbackRender === 'function') {
        return fallbackRender(props);
      } else if (FallbackComponent) {
        return /*#__PURE__*/React.createElement(FallbackComponent, props);
      } else {
        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');
      }
    }

    return this.props.children;
  };

  return ErrorBoundary;
}(React.Component);

function withErrorBoundary(Component, errorBoundaryProps) {
  function Wrapped(props) {
    return /*#__PURE__*/React.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React.createElement(Component, props));
  } // Format for display in DevTools


  var name = Component.displayName || Component.name || 'Unknown';
  Wrapped.displayName = "withErrorBoundary(" + name + ")";
  return Wrapped;
}

function useErrorHandler(givenError) {
  var _React$useState = React.useState(null),
      error = _React$useState[0],
      setError = _React$useState[1];

  if (givenError) throw givenError;
  if (error) throw error;
  return setError;
}

exports.ErrorBoundary = ErrorBoundary;
exports.useErrorHandler = useErrorHandler;
exports.withErrorBoundary = withErrorBoundary;
